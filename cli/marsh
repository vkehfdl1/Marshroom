#!/usr/bin/env bash
set -euo pipefail

STATE_FILE="$HOME/.config/marshroom/state.json"

# â”€â”€â”€ Dependency check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if ! command -v jq &>/dev/null; then
  echo "Error: jq is required but not installed." >&2
  echo "Install with: brew install jq" >&2
  exit 1
fi

# â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Extract owner/repo from a git remote URL (HTTPS or SSH)
extract_owner_repo() {
  local url="$1"
  echo "$url" | sed -E 's#(https?://github\.com/|git@github\.com:)##; s#\.git$##'
}

# Get owner/repo for the current working directory
detect_repo() {
  local remote
  remote=$(git remote get-url origin 2>/dev/null) || {
    echo "Error: Not a git repository or no 'origin' remote." >&2
    return 1
  }
  extract_owner_repo "$remote"
}

# Read state.json safely; returns empty object if missing
read_state() {
  if [[ -f "$STATE_FILE" ]]; then
    cat "$STATE_FILE"
  else
    echo '{}'
  fi
}

# Atomic write: write to temp file then mv
write_state() {
  local tmp
  tmp="$(mktemp "${STATE_FILE}.XXXXXX")"
  cat > "$tmp"
  mv -f "$tmp" "$STATE_FILE"
}

# tmux color for a status value
status_color() {
  case "$1" in
    soon)      echo "yellow"  ;;
    running)   echo "green"   ;;
    pending)   echo "blue"    ;;
    completed) echo "colour244" ;;
    *)         echo "default" ;;
  esac
}

# Pretty status label
status_label() {
  case "$1" in
    soon)      echo "Soon"      ;;
    running)   echo "Running"   ;;
    pending)   echo "Pending"   ;;
    completed) echo "Completed" ;;
    *)         echo "$1"        ;;
  esac
}

# Resolve a cart entry by matching branch name against entries JSON.
# Three-tier matching:
#   Tier 1a: exact branchName match
#   Tier 1b: /#N suffix match (HotFix/#20 matches Feature/#20)
# Outputs: matched entry JSON, or "null" if no match.
resolve_entry_by_branch() {
  local entries="$1"
  local branch="$2"

  if [[ -z "$branch" ]]; then
    echo "null"
    return
  fi

  # Tier 1a: exact branchName match
  local entry
  entry=$(echo "$entries" | jq --arg b "$branch" '
    map(select((.branchName // "") == $b)) | first // null')
  if [[ "$entry" != "null" ]]; then
    echo "$entry"
    return
  fi

  # Tier 1b: /#N suffix match (handles HotFix/#N vs Feature/#N)
  if [[ "$branch" =~ /#[0-9]+$ ]]; then
    local suffix="${BASH_REMATCH[0]}"
    entry=$(echo "$entries" | jq --arg s "$suffix" '
      map(select((.branchName // "") | endswith($s))) | first // null')
    if [[ "$entry" != "null" ]]; then
      echo "$entry"
      return
    fi
  fi

  echo "null"
}

# â”€â”€â”€ Subcommands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_hud() {
  local pane_dir="${1:-}"
  if [[ -n "$pane_dir" && -d "$pane_dir" ]]; then
    cd "$pane_dir"
  fi

  local state owner_repo
  state=$(read_state)

  if [[ "$state" == "{}" ]]; then
    echo "#[fg=colour244]ðŸ„ Marshroom#[fg=default]"
    return 0
  fi

  owner_repo=$(detect_repo 2>/dev/null) || {
    echo "#[fg=colour244]ðŸ„ Marshroom#[fg=default]"
    return 0
  }

  # Find cart entries for this repo
  local entries
  entries=$(echo "$state" | jq -r --arg repo "$owner_repo" '
    .cart // [] | map(
      select(
        (.repoFullName // "") == $repo or
        ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
        ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
      )
    )')

  local count
  count=$(echo "$entries" | jq 'length')

  if [[ "$count" -eq 0 ]]; then
    echo "#[fg=colour244]ðŸ„ ${owner_repo} â€” No tasks#[fg=default]"
    return 0
  fi

  # Tier 1: Match current branch to a cart entry (exact or /#N suffix)
  local branch entry=""
  branch=$(git branch --show-current 2>/dev/null) || branch=""

  if [[ -n "$branch" ]]; then
    entry=$(resolve_entry_by_branch "$entries" "$branch")
    [[ "$entry" == "null" ]] && entry=""
  fi

  # Tier 2: Single entry or sole runner
  if [[ -z "$entry" ]]; then
    if [[ "$count" -eq 1 ]]; then
      entry=$(echo "$entries" | jq 'first')
    else
      local running_count
      running_count=$(echo "$entries" | jq '[.[] | select(.status == "running")] | length')
      if [[ "$running_count" -eq 1 ]]; then
        entry=$(echo "$entries" | jq '[.[] | select(.status == "running")] | first')
      fi
    fi
  fi

  # Tier 3: Summary mode â€” multiple entries, no clear winner
  if [[ -z "$entry" ]]; then
    local running soon pending
    running=$(echo "$entries" | jq '[.[] | select(.status == "running")] | length')
    soon=$(echo "$entries" | jq '[.[] | select(.status == "soon")] | length')
    pending=$(echo "$entries" | jq '[.[] | select(.status == "pending")] | length')
    local parts=()
    [[ "$running" -gt 0 ]] && parts+=("${running} running")
    [[ "$soon" -gt 0 ]]    && parts+=("${soon} soon")
    [[ "$pending" -gt 0 ]] && parts+=("${pending} pending")
    local summary
    summary=$(IFS=', '; echo "${parts[*]}")
    echo "#[fg=yellow]ðŸ„#[fg=default] ${count} tasks (${summary}) | ${owner_repo}"
    return 0
  fi

  local num title status color label
  num=$(echo "$entry" | jq -r '.issueNumber')
  title=$(echo "$entry" | jq -r '.issueTitle')
  status=$(echo "$entry" | jq -r '.status // "soon"')
  color=$(status_color "$status")
  label=$(status_label "$status")

  # Truncate title if too long for tmux bar
  if [[ ${#title} -gt 30 ]]; then
    title="${title:0:27}..."
  fi

  echo "#[fg=${color}]ðŸ„#[fg=default] #${num} ${title} [${label}] | ${owner_repo}"
}

cmd_start() {
  local state owner_repo issue_num
  state=$(read_state)
  owner_repo=$(detect_repo)

  # Get matching cart entries for this repo
  local entries
  entries=$(echo "$state" | jq -r --arg repo "$owner_repo" '
    .cart // [] | map(
      select(
        (.repoFullName // "") == $repo or
        ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
        ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
      )
    )')

  local count
  count=$(echo "$entries" | jq 'length')

  if [[ "$count" -eq 0 ]]; then
    echo "Error: No cart entries found for repo ${owner_repo}." >&2
    exit 1
  fi

  if [[ -n "${1:-}" ]]; then
    # Issue number provided (strip leading #)
    issue_num="${1#\#}"
    local match
    match=$(echo "$entries" | jq --argjson n "$issue_num" 'map(select(.issueNumber == $n)) | first // null')
    if [[ "$match" == "null" ]]; then
      echo "Error: Issue #${issue_num} not found in cart for ${owner_repo}." >&2
      exit 1
    fi
  elif [[ "$count" -eq 1 ]]; then
    issue_num=$(echo "$entries" | jq -r '.[0].issueNumber')
  else
    # Multiple entries â€” list choices
    echo "Multiple cart entries for ${owner_repo}:"
    echo "$entries" | jq -r 'to_entries[] | "  [\(.key + 1)] #\(.value.issueNumber) \(.value.issueTitle) [\(.value.status // "soon")]"'
    echo ""
    read -rp "Select entry number: " choice
    issue_num=$(echo "$entries" | jq -r --argjson i "$((choice - 1))" '.[$i].issueNumber')
    if [[ -z "$issue_num" || "$issue_num" == "null" ]]; then
      echo "Error: Invalid selection." >&2
      exit 1
    fi
  fi

  # Update status to running in state.json
  local updated
  updated=$(echo "$state" | jq --argjson n "$issue_num" --arg repo "$owner_repo" '
    .cart |= map(
      if .issueNumber == $n and (
        (.repoFullName // "") == $repo or
        ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
        ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
      )
      then .status = "running"
      else .
      end
    )')

  echo "$updated" | write_state

  local title
  title=$(echo "$entries" | jq -r --argjson n "$issue_num" 'map(select(.issueNumber == $n)) | first | .issueTitle')
  echo "ðŸ„ Started #${issue_num}: ${title} [Running]"
}

cmd_status() {
  local state owner_repo
  state=$(read_state)

  if [[ "$state" == "{}" ]]; then
    echo "No state.json found. Is Marshroom running?"
    return 0
  fi

  owner_repo=$(detect_repo 2>/dev/null) || {
    echo "Not in a git repository with an origin remote."
    return 0
  }

  local entries
  entries=$(echo "$state" | jq -r --arg repo "$owner_repo" '
    .cart // [] | map(
      select(
        (.repoFullName // "") == $repo or
        ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
        ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
      )
    )')

  local count
  count=$(echo "$entries" | jq 'length')

  echo "ðŸ„ Marshroom â€” ${owner_repo}"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  if [[ "$count" -eq 0 ]]; then
    echo "  No cart entries for this repo."
    return 0
  fi

  local current_branch matched_num=""
  current_branch=$(git branch --show-current 2>/dev/null) || current_branch=""

  if [[ -n "$current_branch" ]]; then
    local matched
    matched=$(resolve_entry_by_branch "$entries" "$current_branch")
    if [[ "$matched" != "null" ]]; then
      matched_num=$(echo "$matched" | jq -r '.issueNumber')
    fi
  fi

  echo "$entries" | jq -r --arg mn "$matched_num" '.[] |
    (if $mn != "" and (.issueNumber | tostring) == $mn then "â†’ " else "  " end) +
    "#\(.issueNumber) \(.issueTitle)\n    Status: \(.status // "soon") | Branch: \(.branchName // "â€”")\(.prURL // "" | if . != "" then "\n    PR: \(.)" else "" end)\n"'
}

open_pycharm() {
  if open -a "PyCharm Professional" "$(pwd)" 2>/dev/null; then
    echo "ðŸ„ Opened PyCharm Professional"
  elif open -a "PyCharm CE" "$(pwd)" 2>/dev/null; then
    echo "ðŸ„ Opened PyCharm CE"
  elif open -a "PyCharm" "$(pwd)" 2>/dev/null; then
    echo "ðŸ„ Opened PyCharm"
  elif command -v pycharm &>/dev/null; then
    pycharm . &
    echo "ðŸ„ Opened PyCharm (CLI launcher)"
  else
    return 1
  fi
}

open_vscode() {
  if open -a "Visual Studio Code" "$(pwd)" 2>/dev/null; then
    echo "ðŸ„ Opened Visual Studio Code"
  elif open -a "Visual Studio Code - Insiders" "$(pwd)" 2>/dev/null; then
    echo "ðŸ„ Opened Visual Studio Code - Insiders"
  elif command -v code &>/dev/null; then
    code .
    echo "ðŸ„ Opened VSCode (CLI launcher)"
  else
    return 1
  fi
}

cmd_open_ide() {
  local ide="${1:-${MARSH_IDE:-}}"

  case "$ide" in
    pycharm)
      open_pycharm || {
        echo "Error: PyCharm not found." >&2
        echo "Install via: brew install --cask pycharm" >&2
        exit 1
      }
      ;;
    vscode)
      open_vscode || {
        echo "Error: VSCode not found." >&2
        echo "Install via: brew install --cask visual-studio-code" >&2
        exit 1
      }
      ;;
    "")
      # Auto-detect: try PyCharm first (backward compat), then VSCode
      open_pycharm 2>/dev/null || open_vscode 2>/dev/null || {
        echo "Error: No supported IDE found (tried PyCharm, VSCode)." >&2
        echo "Install one: brew install --cask pycharm" >&2
        echo "         or: brew install --cask visual-studio-code" >&2
        exit 1
      }
      ;;
    *)
      echo "Error: Unknown IDE '${ide}'. Supported: pycharm, vscode" >&2
      exit 1
      ;;
  esac
}

cmd_pr() {
  local state owner_repo branch
  state=$(read_state)
  owner_repo=$(detect_repo)
  branch=$(git branch --show-current 2>/dev/null) || {
    echo "Error: Could not determine current branch." >&2
    exit 1
  }

  # Get all cart entries for this repo
  local entries
  entries=$(echo "$state" | jq --arg repo "$owner_repo" '
    .cart // [] | map(
      select(
        (.repoFullName // "") == $repo or
        ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
        ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
      )
    )')

  local count
  count=$(echo "$entries" | jq 'length')

  if [[ "$count" -eq 0 ]]; then
    echo "Error: No cart entries found for repo ${owner_repo}." >&2
    exit 1
  fi

  # Tier 1: Branch name match (exact or /#N suffix)
  local entry=""
  entry=$(resolve_entry_by_branch "$entries" "$branch")
  [[ "$entry" == "null" ]] && entry=""

  # Tier 2: Single entry or sole runner
  if [[ -z "$entry" ]]; then
    if [[ "$count" -eq 1 ]]; then
      # Only one cart entry for this repo â†’ use it
      entry=$(echo "$entries" | jq 'first')
    else
      # Check if exactly one entry is "running"
      local running_count
      running_count=$(echo "$entries" | jq '[.[] | select(.status == "running")] | length')
      if [[ "$running_count" -eq 1 ]]; then
        entry=$(echo "$entries" | jq '[.[] | select(.status == "running")] | first')
      fi
    fi
  fi

  # Tier 3: Still no match â†’ provide helpful error
  if [[ -z "$entry" ]]; then
    echo "Error: Cannot determine cart entry for branch '${branch}' in ${owner_repo}." >&2
    echo "" >&2
    echo "Available cart entries:" >&2
    echo "$entries" | jq -r '.[] | "  â€¢ #\(.issueNumber) \(.issueTitle) [\(.status)] - branch: \(.branchName)"' >&2
    echo "" >&2
    echo "Suggestions:" >&2
    echo "  1. Switch to one of the branches listed above" >&2
    echo "  2. If you have only one 'running' issue, set it to 'running' status in the app" >&2
    echo "  3. Ensure your branch name matches a cart entry's branch" >&2
    exit 1
  fi

  local issue_num title
  issue_num=$(echo "$entry" | jq -r '.issueNumber')
  title=$(echo "$entry" | jq -r '.issueTitle')

  # Try to get PR info from gh CLI
  local pr_number="" pr_url=""
  if command -v gh &>/dev/null; then
    local pr_info
    pr_info=$(gh pr view --json number,url -q '.number,.url' 2>/dev/null) || true
    if [[ -n "$pr_info" ]]; then
      pr_number=$(echo "$pr_info" | head -1)
      pr_url=$(echo "$pr_info" | tail -1)
    fi
  fi

  # Update state.json: set status to pending + store PR info
  local updated
  if [[ -n "$pr_number" ]]; then
    updated=$(echo "$state" | jq \
      --argjson n "$issue_num" \
      --arg repo "$owner_repo" \
      --argjson prNum "$pr_number" \
      --arg prUrl "$pr_url" \
      '
      .cart |= map(
        if .issueNumber == $n and (
          (.repoFullName // "") == $repo or
          ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
          ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
        )
        then .status = "pending" | .prNumber = $prNum | .prURL = $prUrl
        else .
        end
      )')
  else
    updated=$(echo "$state" | jq \
      --argjson n "$issue_num" \
      --arg repo "$owner_repo" \
      '
      .cart |= map(
        if .issueNumber == $n and (
          (.repoFullName // "") == $repo or
          ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
          ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
        )
        then .status = "pending"
        else .
        end
      )')
  fi

  echo "$updated" | write_state

  echo "ðŸ„ PR for #${issue_num}: ${title} [Pending]"
  if [[ -n "$pr_url" ]]; then
    echo "  PR: ${pr_url}"
  fi
}

cmd_next() {
  local any_repo=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --any) any_repo=true; shift ;;
      *) echo "Unknown option: $1" >&2; exit 1 ;;
    esac
  done

  local state
  state=$(read_state)

  if [[ "$state" == "{}" ]]; then
    echo "No state.json found." >&2
    exit 1
  fi

  local entries
  if [[ "$any_repo" == true ]]; then
    entries=$(echo "$state" | jq '.cart // [] | map(select(.status == "soon"))')
  else
    local owner_repo
    owner_repo=$(detect_repo)
    entries=$(echo "$state" | jq --arg repo "$owner_repo" '
      .cart // [] | map(
        select(
          (.status == "soon") and (
            (.repoFullName // "") == $repo or
            ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
            ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
          )
        )
      )')
  fi

  local count
  count=$(echo "$entries" | jq 'length')

  if [[ "$count" -eq 0 ]]; then
    echo "No 'soon' items found." >&2
    exit 1
  fi

  # FIFO: first entry in cart array
  local next
  next=$(echo "$entries" | jq 'first')

  # JSON to stdout (machine-readable)
  echo "$next" | jq '{issueNumber, issueTitle, branchName, issueBody, status, repoFullName}'

  # Human summary to stderr
  local num title repo
  num=$(echo "$next" | jq -r '.issueNumber')
  title=$(echo "$next" | jq -r '.issueTitle')
  repo=$(echo "$next" | jq -r '.repoFullName // "unknown"')
  echo "Next: #${num} ${title} (${repo})" >&2
}

cmd_heal() {
  local state owner_repo
  state=$(read_state)
  owner_repo=$(detect_repo)

  local entries
  entries=$(echo "$state" | jq --arg repo "$owner_repo" '
    .cart // [] | map(
      select(
        (.repoFullName // "") == $repo or
        ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
        ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
      )
    )')

  local count
  count=$(echo "$entries" | jq 'length')

  if [[ "$count" -eq 0 ]]; then
    echo "ðŸ„ No cart entries for ${owner_repo}." >&2
    return 0
  fi

  local changed=false
  local updated="$state"

  for ((i = 0; i < count; i++)); do
    local entry status branch issue_num
    entry=$(echo "$entries" | jq --argjson i "$i" '.[$i]')
    status=$(echo "$entry" | jq -r '.status // "soon"')
    branch=$(echo "$entry" | jq -r '.branchName // ""')
    issue_num=$(echo "$entry" | jq -r '.issueNumber')

    case "$status" in
      soon)
        # Branch exists locally â†’ should be running
        if [[ -n "$branch" ]] && git rev-parse --verify "$branch" &>/dev/null; then
          echo "ðŸ”§ #${issue_num}: soon â†’ running (branch '${branch}' exists)" >&2
          updated=$(echo "$updated" | jq --argjson n "$issue_num" '
            .cart |= map(if .issueNumber == $n then .status = "running" else . end)')
          changed=true
        fi
        ;;
      running)
        # PR exists on GitHub â†’ should be pending
        if [[ -n "$branch" ]] && command -v gh &>/dev/null; then
          local pr_json
          pr_json=$(gh pr list --repo "$owner_repo" --head "$branch" --json number,url --jq 'first // empty' 2>/dev/null) || true
          if [[ -n "$pr_json" ]]; then
            local pr_num pr_url
            pr_num=$(echo "$pr_json" | jq -r '.number')
            pr_url=$(echo "$pr_json" | jq -r '.url')
            echo "ðŸ”§ #${issue_num}: running â†’ pending (PR #${pr_num} found)" >&2
            updated=$(echo "$updated" | jq \
              --argjson n "$issue_num" \
              --argjson prNum "$pr_num" \
              --arg prUrl "$pr_url" \
              '.cart |= map(if .issueNumber == $n then .status = "pending" | .prNumber = $prNum | .prURL = $prUrl else . end)')
            changed=true
          fi
        fi
        ;;
    esac
  done

  if [[ "$changed" == true ]]; then
    echo "$updated" | write_state
    echo "ðŸ„ Heal complete â€” state.json updated." >&2
  else
    echo "ðŸ„ All entries healthy for ${owner_repo}." >&2
  fi
}

cmd_help() {
  cat <<'HELP'
ðŸ„ marsh â€” Marshroom CLI

Usage: marsh <command> [options]

Commands:
  hud              Output tmux-formatted status string for current repo
  start [#N]       Mark a cart issue as running (prompts if multiple)
  status           Show cart entries for the current repo
  next [--any]     Show next 'soon' cart item (JSON to stdout, summary to stderr)
  heal             Detect and fix state.json vs git/GitHub mismatches
  open-ide [ide]   Open directory in IDE (pycharm, vscode; auto-detects if omitted)
  pr               Mark current branch's issue as pending (PR created)
  help             Show this help message

State file: ~/.config/marshroom/state.json

Environment variables:
  MARSH_IDE        Default IDE when no argument given (pycharm, vscode)

tmux integration (tpm):
  set -g @plugin 'vkehfdl1/Marshroom'
  set -g status-right '#{marshroom_status} | %H:%M'

Examples:
  marsh hud              # tmux status bar output
  marsh start #42        # start working on issue #42
  marsh start            # interactive pick if multiple issues
  marsh status           # show all cart items for current repo
  marsh open-ide         # auto-detect IDE and open
  marsh open-ide vscode  # open in VSCode
  marsh open-ide pycharm # open in PyCharm
  marsh pr               # mark current branch as PR pending
  marsh next             # JSON of next 'soon' item for current repo
  marsh next --any       # JSON of next 'soon' item across all repos
  marsh heal             # fix state.json mismatches for current repo
HELP
}

# â”€â”€â”€ Main dispatch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

case "${1:-help}" in
  hud)      shift; cmd_hud "${1:-}" ;;
  start)    shift; cmd_start "${1:-}" ;;
  status)   cmd_status ;;
  next)     shift; cmd_next "$@" ;;
  heal)     cmd_heal ;;
  open-ide) shift; cmd_open_ide "${1:-}" ;;
  pr)       cmd_pr ;;
  help|--help|-h) cmd_help ;;
  *)
    echo "Unknown command: $1" >&2
    echo "Run 'marsh help' for usage." >&2
    exit 1
    ;;
esac
