#!/usr/bin/env bash
set -euo pipefail

STATE_FILE="$HOME/.config/marshroom/state.json"

# â”€â”€â”€ Dependency check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if ! command -v jq &>/dev/null; then
  echo "Error: jq is required but not installed." >&2
  echo "Install with: brew install jq" >&2
  exit 1
fi

# â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Extract owner/repo from a git remote URL (HTTPS or SSH)
extract_owner_repo() {
  local url="$1"
  echo "$url" | sed -E 's#(https?://github\.com/|git@github\.com:)##; s#\.git$##'
}

# Get owner/repo for the current working directory
detect_repo() {
  local remote
  remote=$(git remote get-url origin 2>/dev/null) || {
    echo "Error: Not a git repository or no 'origin' remote." >&2
    return 1
  }
  extract_owner_repo "$remote"
}

# Read state.json safely; returns empty object if missing
read_state() {
  if [[ -f "$STATE_FILE" ]]; then
    cat "$STATE_FILE"
  else
    echo '{}'
  fi
}

# Atomic write: write to temp file then mv
write_state() {
  local tmp
  tmp="$(mktemp "${STATE_FILE}.XXXXXX")"
  cat > "$tmp"
  mv -f "$tmp" "$STATE_FILE"
}

# tmux color for a status value
status_color() {
  case "$1" in
    soon)      echo "yellow"  ;;
    running)   echo "green"   ;;
    pending)   echo "blue"    ;;
    completed) echo "colour244" ;;
    *)         echo "default" ;;
  esac
}

# Pretty status label
status_label() {
  case "$1" in
    soon)      echo "Soon"      ;;
    running)   echo "Running"   ;;
    pending)   echo "Pending"   ;;
    completed) echo "Completed" ;;
    *)         echo "$1"        ;;
  esac
}

# Resolve a cart entry by matching branch name against entries JSON.
# Three-tier matching:
#   Tier 1a: exact branchName match
#   Tier 1b: /#N suffix match (HotFix/#20 matches Feature/#20)
# Outputs: matched entry JSON, or "null" if no match.
resolve_entry_by_branch() {
  local entries="$1"
  local branch="$2"

  if [[ -z "$branch" ]]; then
    echo "null"
    return
  fi

  # Tier 1a: exact branchName match
  local entry
  entry=$(echo "$entries" | jq --arg b "$branch" '
    map(select((.branchName // "") == $b)) | first // null')
  if [[ "$entry" != "null" ]]; then
    echo "$entry"
    return
  fi

  # Tier 1b: /#N suffix match (handles HotFix/#N vs Feature/#N)
  if [[ "$branch" =~ /#[0-9]+$ ]]; then
    local suffix="${BASH_REMATCH[0]}"
    entry=$(echo "$entries" | jq --arg s "$suffix" '
      map(select((.branchName // "") | endswith($s))) | first // null')
    if [[ "$entry" != "null" ]]; then
      echo "$entry"
      return
    fi
  fi

  echo "null"
}

# Resolve local directory for a repo given its full name and URLs.
# Tier 1: localPath from state.json repos[]
# Tier 2: Scan MARSH_AUTORUN_DIRS for matching git remote
# Tier 3: Return 1 (not found)
resolve_repo_dir() {
  local repo_full_name="$1"
  local repo_clone_url="${2:-}"
  local repo_ssh_url="${3:-}"

  local state
  state=$(read_state)

  # Tier 1: localPath from state.json repos[]
  local local_path
  local_path=$(echo "$state" | jq -r --arg repo "$repo_full_name" '
    .repos // [] | map(select(.fullName == $repo)) | first // null | .localPath // empty')
  if [[ -n "${local_path:-}" && -d "$local_path" ]]; then
    echo "$local_path"
    return 0
  fi

  # Tier 2: Scan MARSH_AUTORUN_DIRS
  local search_dirs="${MARSH_AUTORUN_DIRS:-$HOME/xcode-projects:$HOME/projects:$HOME/repos:$HOME/src:$HOME/code}"
  IFS=':' read -ra dirs <<< "$search_dirs"
  for base_dir in "${dirs[@]}"; do
    [[ -d "$base_dir" ]] || continue
    for sub_dir in "$base_dir"/*/; do
      [[ -d "$sub_dir/.git" ]] || continue
      local remote
      remote=$(git -C "$sub_dir" remote get-url origin 2>/dev/null) || continue
      local found_repo
      found_repo=$(extract_owner_repo "$remote")
      if [[ "$found_repo" == "$repo_full_name" ]]; then
        echo "${sub_dir%/}"
        return 0
      fi
    done
  done

  # Tier 3: Not found
  return 1
}

# â”€â”€â”€ Subcommands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_hud() {
  local pane_dir="${1:-}"
  if [[ -n "$pane_dir" && -d "$pane_dir" ]]; then
    cd "$pane_dir"
  fi

  local state owner_repo
  state=$(read_state)

  if [[ "$state" == "{}" ]]; then
    echo "#[fg=colour244]ğŸ„ Marshroom#[fg=default]"
    return 0
  fi

  owner_repo=$(detect_repo 2>/dev/null) || {
    echo "#[fg=colour244]ğŸ„ Marshroom#[fg=default]"
    return 0
  }

  # Find cart entries for this repo
  local entries
  entries=$(echo "$state" | jq -r --arg repo "$owner_repo" '
    .cart // [] | map(
      select(
        (.repoFullName // "") == $repo or
        ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
        ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
      )
    )')

  local count
  count=$(echo "$entries" | jq 'length')

  if [[ "$count" -eq 0 ]]; then
    echo "#[fg=colour244]ğŸ„ ${owner_repo} â€” No tasks#[fg=default]"
    return 0
  fi

  # Tier 1: Match current branch to a cart entry (exact or /#N suffix)
  local branch entry=""
  branch=$(git branch --show-current 2>/dev/null) || branch=""

  if [[ -n "$branch" ]]; then
    entry=$(resolve_entry_by_branch "$entries" "$branch")
    [[ "$entry" == "null" ]] && entry=""
  fi

  # Tier 2: Single entry or sole runner
  if [[ -z "$entry" ]]; then
    if [[ "$count" -eq 1 ]]; then
      entry=$(echo "$entries" | jq 'first')
    else
      local running_count
      running_count=$(echo "$entries" | jq '[.[] | select(.status == "running")] | length')
      if [[ "$running_count" -eq 1 ]]; then
        entry=$(echo "$entries" | jq '[.[] | select(.status == "running")] | first')
      fi
    fi
  fi

  # Tier 3: Summary mode â€” multiple entries, no clear winner
  if [[ -z "$entry" ]]; then
    local running soon pending
    running=$(echo "$entries" | jq '[.[] | select(.status == "running")] | length')
    soon=$(echo "$entries" | jq '[.[] | select(.status == "soon")] | length')
    pending=$(echo "$entries" | jq '[.[] | select(.status == "pending")] | length')
    local parts=()
    [[ "$running" -gt 0 ]] && parts+=("${running} running")
    [[ "$soon" -gt 0 ]]    && parts+=("${soon} soon")
    [[ "$pending" -gt 0 ]] && parts+=("${pending} pending")
    local summary
    summary=$(IFS=', '; echo "${parts[*]}")
    echo "#[fg=yellow]ğŸ„#[fg=default] ${count} tasks (${summary}) | ${owner_repo}"
    return 0
  fi

  local num title status color label
  num=$(echo "$entry" | jq -r '.issueNumber')
  title=$(echo "$entry" | jq -r '.issueTitle')
  status=$(echo "$entry" | jq -r '.status // "soon"')
  color=$(status_color "$status")
  label=$(status_label "$status")

  # Truncate title if too long for tmux bar
  if [[ ${#title} -gt 30 ]]; then
    title="${title:0:27}..."
  fi

  echo "#[fg=${color}]ğŸ„#[fg=default] #${num} ${title} [${label}] | ${owner_repo}"
}

cmd_start() {
  local state owner_repo issue_num
  state=$(read_state)
  owner_repo=$(detect_repo)

  # Get matching cart entries for this repo
  local entries
  entries=$(echo "$state" | jq -r --arg repo "$owner_repo" '
    .cart // [] | map(
      select(
        (.repoFullName // "") == $repo or
        ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
        ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
      )
    )')

  local count
  count=$(echo "$entries" | jq 'length')

  if [[ "$count" -eq 0 ]]; then
    echo "Error: No cart entries found for repo ${owner_repo}." >&2
    exit 1
  fi

  if [[ -n "${1:-}" ]]; then
    # Issue number provided (strip leading #)
    issue_num="${1#\#}"
    local match
    match=$(echo "$entries" | jq --argjson n "$issue_num" 'map(select(.issueNumber == $n)) | first // null')
    if [[ "$match" == "null" ]]; then
      echo "Error: Issue #${issue_num} not found in cart for ${owner_repo}." >&2
      exit 1
    fi
  elif [[ "$count" -eq 1 ]]; then
    issue_num=$(echo "$entries" | jq -r '.[0].issueNumber')
  else
    # Multiple entries â€” list choices
    echo "Multiple cart entries for ${owner_repo}:"
    echo "$entries" | jq -r 'to_entries[] | "  [\(.key + 1)] #\(.value.issueNumber) \(.value.issueTitle) [\(.value.status // "soon")]"'
    echo ""
    read -rp "Select entry number: " choice
    issue_num=$(echo "$entries" | jq -r --argjson i "$((choice - 1))" '.[$i].issueNumber')
    if [[ -z "$issue_num" || "$issue_num" == "null" ]]; then
      echo "Error: Invalid selection." >&2
      exit 1
    fi
  fi

  # Update status to running in state.json
  local updated
  updated=$(echo "$state" | jq --argjson n "$issue_num" --arg repo "$owner_repo" '
    .cart |= map(
      if .issueNumber == $n and (
        (.repoFullName // "") == $repo or
        ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
        ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
      )
      then .status = "running"
      else .
      end
    )')

  echo "$updated" | write_state

  local title
  title=$(echo "$entries" | jq -r --argjson n "$issue_num" 'map(select(.issueNumber == $n)) | first | .issueTitle')
  echo "ğŸ„ Started #${issue_num}: ${title} [Running]"
}

cmd_status() {
  local state owner_repo
  state=$(read_state)

  if [[ "$state" == "{}" ]]; then
    echo "No state.json found. Is Marshroom running?"
    return 0
  fi

  owner_repo=$(detect_repo 2>/dev/null) || {
    echo "Not in a git repository with an origin remote."
    return 0
  }

  local entries
  entries=$(echo "$state" | jq -r --arg repo "$owner_repo" '
    .cart // [] | map(
      select(
        (.repoFullName // "") == $repo or
        ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
        ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
      )
    )')

  local count
  count=$(echo "$entries" | jq 'length')

  echo "ğŸ„ Marshroom â€” ${owner_repo}"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  if [[ "$count" -eq 0 ]]; then
    echo "  No cart entries for this repo."
    return 0
  fi

  local current_branch matched_num=""
  current_branch=$(git branch --show-current 2>/dev/null) || current_branch=""

  if [[ -n "$current_branch" ]]; then
    local matched
    matched=$(resolve_entry_by_branch "$entries" "$current_branch")
    if [[ "$matched" != "null" ]]; then
      matched_num=$(echo "$matched" | jq -r '.issueNumber')
    fi
  fi

  echo "$entries" | jq -r --arg mn "$matched_num" '.[] |
    (if $mn != "" and (.issueNumber | tostring) == $mn then "â†’ " else "  " end) +
    "#\(.issueNumber) \(.issueTitle)\n    Status: \(.status // "soon") | Branch: \(.branchName // "â€”")\(.prURL // "" | if . != "" then "\n    PR: \(.)" else "" end)\n"'
}

open_pycharm() {
  if open -a "PyCharm Professional" "$(pwd)" 2>/dev/null; then
    echo "ğŸ„ Opened PyCharm Professional"
  elif open -a "PyCharm CE" "$(pwd)" 2>/dev/null; then
    echo "ğŸ„ Opened PyCharm CE"
  elif open -a "PyCharm" "$(pwd)" 2>/dev/null; then
    echo "ğŸ„ Opened PyCharm"
  elif command -v pycharm &>/dev/null; then
    pycharm . &
    echo "ğŸ„ Opened PyCharm (CLI launcher)"
  else
    return 1
  fi
}

open_vscode() {
  if open -a "Visual Studio Code" "$(pwd)" 2>/dev/null; then
    echo "ğŸ„ Opened Visual Studio Code"
  elif open -a "Visual Studio Code - Insiders" "$(pwd)" 2>/dev/null; then
    echo "ğŸ„ Opened Visual Studio Code - Insiders"
  elif command -v code &>/dev/null; then
    code .
    echo "ğŸ„ Opened VSCode (CLI launcher)"
  else
    return 1
  fi
}

cmd_open_ide() {
  local ide="${1:-${MARSH_IDE:-}}"

  case "$ide" in
    pycharm)
      open_pycharm || {
        echo "Error: PyCharm not found." >&2
        echo "Install via: brew install --cask pycharm" >&2
        exit 1
      }
      ;;
    vscode)
      open_vscode || {
        echo "Error: VSCode not found." >&2
        echo "Install via: brew install --cask visual-studio-code" >&2
        exit 1
      }
      ;;
    "")
      # Auto-detect: try PyCharm first (backward compat), then VSCode
      open_pycharm 2>/dev/null || open_vscode 2>/dev/null || {
        echo "Error: No supported IDE found (tried PyCharm, VSCode)." >&2
        echo "Install one: brew install --cask pycharm" >&2
        echo "         or: brew install --cask visual-studio-code" >&2
        exit 1
      }
      ;;
    *)
      echo "Error: Unknown IDE '${ide}'. Supported: pycharm, vscode" >&2
      exit 1
      ;;
  esac
}

cmd_pr() {
  local state owner_repo branch
  state=$(read_state)
  owner_repo=$(detect_repo)
  branch=$(git branch --show-current 2>/dev/null) || {
    echo "Error: Could not determine current branch." >&2
    exit 1
  }

  # Get all cart entries for this repo
  local entries
  entries=$(echo "$state" | jq --arg repo "$owner_repo" '
    .cart // [] | map(
      select(
        (.repoFullName // "") == $repo or
        ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
        ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
      )
    )')

  local count
  count=$(echo "$entries" | jq 'length')

  if [[ "$count" -eq 0 ]]; then
    echo "Error: No cart entries found for repo ${owner_repo}." >&2
    exit 1
  fi

  # Tier 1: Branch name match (exact or /#N suffix)
  local entry=""
  entry=$(resolve_entry_by_branch "$entries" "$branch")
  [[ "$entry" == "null" ]] && entry=""

  # Tier 2: Single entry or sole runner
  if [[ -z "$entry" ]]; then
    if [[ "$count" -eq 1 ]]; then
      # Only one cart entry for this repo â†’ use it
      entry=$(echo "$entries" | jq 'first')
    else
      # Check if exactly one entry is "running"
      local running_count
      running_count=$(echo "$entries" | jq '[.[] | select(.status == "running")] | length')
      if [[ "$running_count" -eq 1 ]]; then
        entry=$(echo "$entries" | jq '[.[] | select(.status == "running")] | first')
      fi
    fi
  fi

  # Tier 3: Still no match â†’ provide helpful error
  if [[ -z "$entry" ]]; then
    echo "Error: Cannot determine cart entry for branch '${branch}' in ${owner_repo}." >&2
    echo "" >&2
    echo "Available cart entries:" >&2
    echo "$entries" | jq -r '.[] | "  â€¢ #\(.issueNumber) \(.issueTitle) [\(.status)] - branch: \(.branchName)"' >&2
    echo "" >&2
    echo "Suggestions:" >&2
    echo "  1. Switch to one of the branches listed above" >&2
    echo "  2. If you have only one 'running' issue, set it to 'running' status in the app" >&2
    echo "  3. Ensure your branch name matches a cart entry's branch" >&2
    exit 1
  fi

  local issue_num title
  issue_num=$(echo "$entry" | jq -r '.issueNumber')
  title=$(echo "$entry" | jq -r '.issueTitle')

  # Try to get PR info from gh CLI
  local pr_number="" pr_url=""
  if command -v gh &>/dev/null; then
    local pr_info
    pr_info=$(gh pr view --json number,url -q '.number,.url' 2>/dev/null) || true
    if [[ -n "$pr_info" ]]; then
      pr_number=$(echo "$pr_info" | head -1)
      pr_url=$(echo "$pr_info" | tail -1)
    fi
  fi

  # Update state.json: set status to pending + store PR info
  local updated
  if [[ -n "$pr_number" ]]; then
    updated=$(echo "$state" | jq \
      --argjson n "$issue_num" \
      --arg repo "$owner_repo" \
      --argjson prNum "$pr_number" \
      --arg prUrl "$pr_url" \
      '
      .cart |= map(
        if .issueNumber == $n and (
          (.repoFullName // "") == $repo or
          ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
          ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
        )
        then .status = "pending" | .prNumber = $prNum | .prURL = $prUrl
        else .
        end
      )')
  else
    updated=$(echo "$state" | jq \
      --argjson n "$issue_num" \
      --arg repo "$owner_repo" \
      '
      .cart |= map(
        if .issueNumber == $n and (
          (.repoFullName // "") == $repo or
          ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
          ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
        )
        then .status = "pending"
        else .
        end
      )')
  fi

  echo "$updated" | write_state

  echo "ğŸ„ PR for #${issue_num}: ${title} [Pending]"
  if [[ -n "$pr_url" ]]; then
    echo "  PR: ${pr_url}"
  fi
}

cmd_next() {
  local any_repo=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --any) any_repo=true; shift ;;
      *) echo "Unknown option: $1" >&2; exit 1 ;;
    esac
  done

  local state
  state=$(read_state)

  if [[ "$state" == "{}" ]]; then
    echo "No state.json found." >&2
    exit 1
  fi

  local entries
  if [[ "$any_repo" == true ]]; then
    entries=$(echo "$state" | jq '.cart // [] | map(select(.status == "soon"))')
  else
    local owner_repo
    owner_repo=$(detect_repo)
    entries=$(echo "$state" | jq --arg repo "$owner_repo" '
      .cart // [] | map(
        select(
          (.status == "soon") and (
            (.repoFullName // "") == $repo or
            ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
            ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
          )
        )
      )')
  fi

  local count
  count=$(echo "$entries" | jq 'length')

  if [[ "$count" -eq 0 ]]; then
    echo "No 'soon' items found." >&2
    exit 1
  fi

  # FIFO: first entry in cart array
  local next
  next=$(echo "$entries" | jq 'first')

  # JSON to stdout (machine-readable)
  echo "$next" | jq '{issueNumber, issueTitle, branchName, issueBody, status, repoFullName, repoCloneURL, repoSSHURL}'

  # Human summary to stderr
  local num title repo
  num=$(echo "$next" | jq -r '.issueNumber')
  title=$(echo "$next" | jq -r '.issueTitle')
  repo=$(echo "$next" | jq -r '.repoFullName // "unknown"')
  echo "Next: #${num} ${title} (${repo})" >&2
}

cmd_heal() {
  local state owner_repo
  state=$(read_state)
  owner_repo=$(detect_repo)

  local entries
  entries=$(echo "$state" | jq --arg repo "$owner_repo" '
    .cart // [] | map(
      select(
        (.repoFullName // "") == $repo or
        ((.repoCloneURL // "") | gsub("https://github.com/"; "") | gsub("\\.git$"; "")) == $repo or
        ((.repoSSHURL // "")   | gsub("git@github.com:"; "")    | gsub("\\.git$"; "")) == $repo
      )
    )')

  local count
  count=$(echo "$entries" | jq 'length')

  if [[ "$count" -eq 0 ]]; then
    echo "ğŸ„ No cart entries for ${owner_repo}." >&2
    return 0
  fi

  local changed=false
  local updated="$state"

  for ((i = 0; i < count; i++)); do
    local entry status branch issue_num
    entry=$(echo "$entries" | jq --argjson i "$i" '.[$i]')
    status=$(echo "$entry" | jq -r '.status // "soon"')
    branch=$(echo "$entry" | jq -r '.branchName // ""')
    issue_num=$(echo "$entry" | jq -r '.issueNumber')

    case "$status" in
      soon)
        # Branch exists locally â†’ should be running
        if [[ -n "$branch" ]] && git rev-parse --verify "$branch" &>/dev/null; then
          echo "ğŸ”§ #${issue_num}: soon â†’ running (branch '${branch}' exists)" >&2
          updated=$(echo "$updated" | jq --argjson n "$issue_num" '
            .cart |= map(if .issueNumber == $n then .status = "running" else . end)')
          changed=true
        fi
        ;;
      running)
        # PR exists on GitHub â†’ should be pending
        if [[ -n "$branch" ]] && command -v gh &>/dev/null; then
          local pr_json
          pr_json=$(gh pr list --repo "$owner_repo" --head "$branch" --json number,url --jq 'first // empty' 2>/dev/null) || true
          if [[ -n "$pr_json" ]]; then
            local pr_num pr_url
            pr_num=$(echo "$pr_json" | jq -r '.number')
            pr_url=$(echo "$pr_json" | jq -r '.url')
            echo "ğŸ”§ #${issue_num}: running â†’ pending (PR #${pr_num} found)" >&2
            updated=$(echo "$updated" | jq \
              --argjson n "$issue_num" \
              --argjson prNum "$pr_num" \
              --arg prUrl "$pr_url" \
              '.cart |= map(if .issueNumber == $n then .status = "pending" | .prNumber = $prNum | .prURL = $prUrl else . end)')
            changed=true
          fi
        fi
        ;;
    esac
  done

  if [[ "$changed" == true ]]; then
    echo "$updated" | write_state
    echo "ğŸ„ Heal complete â€” state.json updated." >&2
  else
    echo "ğŸ„ All entries healthy for ${owner_repo}." >&2
  fi
}

autorun_log() {
  echo "[$(date '+%H:%M:%S')] $*" >&2
}

cmd_autorun() {
  local agent="claude"
  local max_issues=0
  local cooldown=10
  local dry_run=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --agent)    agent="$2"; shift 2 ;;
      --max)      max_issues="$2"; shift 2 ;;
      --cooldown) cooldown="$2"; shift 2 ;;
      --dry-run)  dry_run=true; shift ;;
      *)
        echo "Unknown option: $1" >&2
        echo "Usage: marsh autorun [--agent claude|codex] [--max N] [--cooldown SECONDS] [--dry-run]" >&2
        exit 1
        ;;
    esac
  done

  # Validate numeric flags
  if ! [[ "$max_issues" =~ ^[0-9]+$ ]]; then
    echo "Error: --max must be a non-negative integer" >&2; exit 1
  fi
  if ! [[ "$cooldown" =~ ^[0-9]+$ ]]; then
    echo "Error: --cooldown must be a non-negative integer" >&2; exit 1
  fi

  # Preflight: verify agent CLI
  case "$agent" in
    claude)
      if ! command -v claude &>/dev/null; then
        echo "Error: 'claude' CLI not found in PATH." >&2
        echo "Install: https://docs.anthropic.com/en/docs/claude-code" >&2
        exit 1
      fi
      ;;
    codex)
      if ! command -v codex &>/dev/null; then
        echo "Error: 'codex' CLI not found in PATH." >&2
        exit 1
      fi
      ;;
    *)
      echo "Error: Unknown agent '${agent}'. Supported: claude, codex" >&2
      exit 1
      ;;
  esac

  # Create log directory
  local log_dir="$HOME/.config/marshroom/autorun-logs"
  mkdir -p "$log_dir"

  # Counters
  local processed=0 succeeded=0 failed=0 skipped=0

  # Track skipped repos and seen issues to avoid infinite FIFO loop (colon-separated for bash 3 compat)
  local skipped_repos=""
  local seen_issues=""

  # Signal handling
  local stop_flag=false
  local agent_pid=""
  trap_handler() {
    autorun_log "Caught signal â€” shutting down gracefully..."
    stop_flag=true
    if [[ -n "$agent_pid" ]] && kill -0 "$agent_pid" 2>/dev/null; then
      autorun_log "Terminating agent process (PID $agent_pid)..."
      kill "$agent_pid" 2>/dev/null || true
      wait "$agent_pid" 2>/dev/null || true
    fi
  }
  trap trap_handler SIGINT SIGTERM

  autorun_log "ğŸ„ marsh autorun â€” agent=${agent}, max=${max_issues:-unlimited}, cooldown=${cooldown}s, dry_run=${dry_run}"

  while true; do
    if [[ "$stop_flag" == true ]]; then
      break
    fi

    # Check max limit
    if [[ "$max_issues" -gt 0 && "$processed" -ge "$max_issues" ]]; then
      autorun_log "Reached max issues limit (${max_issues}). Stopping."
      break
    fi

    # Get next soon item
    local next_json
    next_json=$(cmd_next --any 2>/dev/null) || {
      autorun_log "No more 'soon' items in cart. Done."
      break
    }

    local issue_num issue_title repo_full_name repo_clone_url repo_ssh_url
    issue_num=$(echo "$next_json" | jq -r '.issueNumber')
    issue_title=$(echo "$next_json" | jq -r '.issueTitle')
    repo_full_name=$(echo "$next_json" | jq -r '.repoFullName // ""')
    repo_clone_url=$(echo "$next_json" | jq -r '.repoCloneURL // ""')
    repo_ssh_url=$(echo "$next_json" | jq -r '.repoSSHURL // ""')

    # Check if we've already seen this issue (avoid infinite loop in dry-run or on failure)
    if [[ ":${seen_issues}:" == *":${issue_num}:"* ]]; then
      autorun_log "Already processed #${issue_num} â€” no more new items. Stopping."
      break
    fi
    seen_issues="${seen_issues}:${issue_num}"

    # Check if we've already skipped this repo (avoid infinite loop)
    if [[ ":${skipped_repos}:" == *":${repo_full_name}:"* ]]; then
      # Already know this repo is unresolvable; track as seen to avoid infinite loop
      seen_issues="${seen_issues}:${issue_num}"
      skipped=$((skipped + 1))
      continue
    fi

    autorun_log "Processing #${issue_num}: ${issue_title} (${repo_full_name})"

    # Resolve local directory
    local repo_dir
    repo_dir=$(resolve_repo_dir "$repo_full_name" "$repo_clone_url" "$repo_ssh_url") || {
      autorun_log "SKIP: Cannot resolve local directory for ${repo_full_name}"
      skipped_repos="${skipped_repos}:${repo_full_name}"
      skipped=$((skipped + 1))
      continue
    }

    autorun_log "Resolved directory: ${repo_dir}"

    if [[ "$dry_run" == true ]]; then
      autorun_log "DRY RUN: Would run /run-issue #${issue_num} in ${repo_dir}"
      processed=$((processed + 1))
      succeeded=$((succeeded + 1))
      continue
    fi

    # Spawn agent
    local log_file="${log_dir}/autorun-$(date '+%Y%m%d-%H%M%S')-${issue_num}.log"
    autorun_log "Spawning ${agent} for #${issue_num} â€” log: ${log_file}"

    local exit_code=0
    case "$agent" in
      claude)
        (cd "$repo_dir" && claude -p "/run-issue #${issue_num}") \
          > "$log_file" 2>&1 &
        agent_pid=$!
        ;;
      codex)
        (cd "$repo_dir" && codex exec --sandbox danger-full-access "/run-issue #${issue_num}") \
          > "$log_file" 2>&1 &
        agent_pid=$!
        ;;
    esac

    wait "$agent_pid" || exit_code=$?
    agent_pid=""
    processed=$((processed + 1))

    if [[ "$exit_code" -eq 0 ]]; then
      autorun_log "Completed #${issue_num} successfully"
      succeeded=$((succeeded + 1))
    else
      autorun_log "FAILED #${issue_num} (exit code ${exit_code}) â€” see ${log_file}"
      failed=$((failed + 1))
    fi

    # Heal state from repo dir
    autorun_log "Running heal for ${repo_full_name}..."
    (cd "$repo_dir" && cmd_heal) 2>/dev/null || true

    if [[ "$stop_flag" == true ]]; then
      break
    fi

    # Cooldown
    if [[ "$cooldown" -gt 0 ]]; then
      autorun_log "Cooldown ${cooldown}s..."
      sleep "$cooldown" &
      wait $! 2>/dev/null || true
    fi
  done

  # Summary
  autorun_log "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  autorun_log "ğŸ„ marsh autorun complete"
  autorun_log "  Processed: ${processed}"
  autorun_log "  Succeeded: ${succeeded}"
  autorun_log "  Failed:    ${failed}"
  autorun_log "  Skipped:   ${skipped}"
  autorun_log "  Logs:      ${log_dir}/"
  autorun_log "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
}

cmd_help() {
  cat <<'HELP'
ğŸ„ marsh â€” Marshroom CLI

Usage: marsh <command> [options]

Commands:
  hud              Output tmux-formatted status string for current repo
  start [#N]       Mark a cart issue as running (prompts if multiple)
  status           Show cart entries for the current repo
  next [--any]     Show next 'soon' cart item (JSON to stdout, summary to stderr)
  heal             Detect and fix state.json vs git/GitHub mismatches
  open-ide [ide]   Open directory in IDE (pycharm, vscode; auto-detects if omitted)
  pr               Mark current branch's issue as pending (PR created)
  autorun          Autonomous loop: pick soon items, run full GOAT lifecycle
  help             Show this help message

State file: ~/.config/marshroom/state.json

Environment variables:
  MARSH_IDE            Default IDE when no argument given (pycharm, vscode)
  MARSH_AUTORUN_DIRS   Colon-separated dirs to scan for repos (autorun)

tmux integration (tpm):
  set -g @plugin 'vkehfdl1/Marshroom'
  set -g status-right '#{marshroom_status} | %H:%M'

Examples:
  marsh hud              # tmux status bar output
  marsh start #42        # start working on issue #42
  marsh start            # interactive pick if multiple issues
  marsh status           # show all cart items for current repo
  marsh open-ide         # auto-detect IDE and open
  marsh open-ide vscode  # open in VSCode
  marsh open-ide pycharm # open in PyCharm
  marsh pr               # mark current branch as PR pending
  marsh next             # JSON of next 'soon' item for current repo
  marsh next --any       # JSON of next 'soon' item across all repos
  marsh heal             # fix state.json mismatches for current repo
  marsh autorun          # run full GOAT lifecycle on all soon items
  marsh autorun --max 3  # process at most 3 issues
  marsh autorun --dry-run # preview what would be processed
  marsh autorun --agent codex --cooldown 30  # use codex with 30s cooldown
HELP
}

# â”€â”€â”€ Main dispatch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

case "${1:-help}" in
  hud)      shift; cmd_hud "${1:-}" ;;
  start)    shift; cmd_start "${1:-}" ;;
  status)   cmd_status ;;
  next)     shift; cmd_next "$@" ;;
  heal)     cmd_heal ;;
  open-ide) shift; cmd_open_ide "${1:-}" ;;
  pr)       cmd_pr ;;
  autorun)  shift; cmd_autorun "$@" ;;
  help|--help|-h) cmd_help ;;
  *)
    echo "Unknown command: $1" >&2
    echo "Run 'marsh help' for usage." >&2
    exit 1
    ;;
esac
